package SuiDesigner3d_w3e

#include "../Orc/Orc.h"
#include <stdio.h>
#include <math.h>

import * from "../Orc/String.orc"
import * from "../Orc/List.orc"
import * from "../Orc/Map.orc"
import * from "../Orc/Time.orc"
import * from "../Orc/Math.orc"
import * from "../Orc/Path.orc"
import * from "../Json/Json.orc"
import * from "../Sui/Core/Window.orc"
import * from "../Sui/Core/Node.orc"
import * from "../Sui/Core/ViewBase.orc"
import * from "../Sui/Core/View.orc"
import * from "../Sui/Core/Vec3.orc"
import * from "../Sui/Core/Vec2.orc"
import * from "../Sui/Core/Rect.orc"
import * from "../Sui/Core/Event.orc"
import * from "../Sui/Core/Image.orc"
import * from "../Sui/Core/Frame.orc"
import * from "../Sui/Core/Mouse.orc"
import * from "../Sui/Core/MouseEvent.orc"
import * from "../Sui/View/TextView.orc"
import * from "../Sui/View/EditText.orc"
import * from "../Sui/View/Button.orc"
import * from "../Sui/View/ImageView.orc"
import * from "../Sui/View/HoverViewEffect.orc"
import * from "../Sui/View/ViewBuilder.orc"
import * from "../Sui/View/ScrollArea.orc"
import * from "../Sui/Dialog/Toast.orc"
import * from "../Sui/Dialog/FileDialog.orc"
import * from "../Sui/Dialog/MessageDialog.orc"
import * from "../Sui/Layout/LayoutLinear.orc"
import * from "../Sui/Layout/LayoutAlign.orc"
import * from "../Sui/View/DockLayout.orc"
import * from "../Sui/View/Drag.orc"
import * from "../Sui/View/MenuNative.orc"
import * from "../Sui/Core/Timer.orc"
import * from "../Sui/Core/Canvas.orc"
import * from "../Sgl/Buffer.orc"
import * from "../SuiDesigner/DrawDegree.orc"
import * from "./ChessBgViewCallback.orc"
import * from "./Theme.orc"
import * from "./InvalidReact.orc"
import * from "./MenuBarCtrl.orc"
import * from "../Sgl/Material.orc"
import * from "../Sgl/Geometry.orc"
import * from "../Sgl/Vbo.orc"
import * from "../Sgl/Tex2d.orc"


class W3eCorner {
    //地面高度. 以层为单位。 层高128. 实际高为 (groundHeight+layer-2)*128. viewer "*128"是在vert.glsl中计算
    float groundHeight = 0;
    //水面高度. 水和地面高度是分开的
    float waterHeight = 0; //按层为单位
    bool mapEdge = 0;//boundary flag 1 (shadow generated by the world editor on the edge of the map)
    //坡:0/16
    bool ramp = 0;
    bool blight = 0; //不死之地
    //是否有水 0/64
    bool water = 0;
    bool boundary = 0; //used on "camera bounds" area. Usually set by the World Editor "boundary" tool
    //tile 纹理坐标由 tile的四个点的groundTexture计算得出
    int groundTexture = 0; //纹理索引。对于W3e的tilesets数据,所以一个点只用一个纹理
    //防止重复，同一类的悬崖模型有多个。 值由cliffVariation决定0-2
    int cliffVariation = 0;
    // 0-15. 减少重复感
    //有出现16,17的值。。16是原图,即15. 0-15 => 16+v,  大于16返回0
    int groundVariation = 0; // Which variation of the texture to use (bones, holes, etc...). This is to reduce the amount of repetition. 是不是。如果是全覆盖的纹理，需要此标志来减少重复
    //悬崖规则： 比较tile的四个顶， 与最低的按层高比较：得到 1,0, 0, 0.  0转为'A', 1转为'A'+1=>'B',再拼起来`Cliffs${tl}${tr}${bl}${br}${cliffVariation}.mdx`
    int cliffTexture = 0;
    int layerHeight = 0;

    float actualGroundHeight = 0 // 实际高度

    void calcActualGroundHeight(){
        self.actualGroundHeight = (self.groundHeight + self.layerHeight - 2) * 128.0
    }

    void load(BufferReader *stream){

        //原始数据： 层高128,原始数据以层高的4倍存储. 8192是0点位置
        //实际上groundHeight存放的不是真实高度。 而是当前层里的位置 。
        //计算时，需要 加上层的高度
        self.groundHeight = (stream.readInt16() - 8192) / 512.0;

        short waterAndEdge = stream.readInt16();

        //89.6是water zero level
        //实际上还需要考虑water.slk中的height数据。该数据定义water zero 的高度值. 如-0.7，就相当于最终层还要再-0.7
        short waterH = (waterAndEdge & 0x3FFF) 
        self.waterHeight = ((waterAndEdge & 0x3FFF) - 8192) / 512;// - 89.6 / 128;
        self.mapEdge = waterAndEdge & 0x4000;

        short textureAndFlags = stream.readUint8();

        self.ramp = textureAndFlags & 0b00010000;
        self.blight = textureAndFlags & 0b00100000;
        self.water = textureAndFlags & 0b01000000;
        self.boundary = textureAndFlags & 0b10000000;

        self.groundTexture = textureAndFlags & 0b00001111;

        unsigned char variation = stream.readUint8();

        self.cliffVariation = (variation & 0b11100000) >> 5;
        self.groundVariation = variation & 0b00011111;

        unsigned char cliffTextureAndLayer = stream.readUint8();

        self.cliffTexture = (cliffTextureAndLayer & 0b11110000) >> 4;
        self.layerHeight = cliffTextureAndLayer & 0b00001111;

        self.calcActualGroundHeight()
    }
}

//解析.w3e文件
class W3e {
    String@ head = str("")
    int version
    char tileset
    int haveCustomTileset
    int groundTilesetCount;

    List@ groundTilesetNames = new List();
    int cliffTilesetCount;
    List@ cliffTilesetNames = new List();

    IntVec2 mapSize;
    Vec2 centerOffset;
    List@ corners = new List()

    List@ groundTexs = new List()


    Geometry@ mkGeometry(){
        Buffer@ buf = new Buffer()
        Buffer@ face = new Buffer()

        //一个Tile两个三角面。 一个面三个顶点。 一个面可能有4种纹理组合(每个顶点都归属于不同的纹理). 用tilesets表示此面用到哪些纹理和顺序。uv0-3对应tilesets的顺序
        //shaders中各顶点的tilesets是一样的。所以不用管插值。 uv0-3直接算出来是具体subtile的uv. shader中直接按混合即可
        Buffer@ tilesets = new Buffer()
        Buffer@ uv0 = new Buffer()
        Buffer@ uv1 = new Buffer()
        Buffer@ uv2 = new Buffer()
        Buffer@ uv3 = new Buffer()

        float tilew = 128.0 

        int vertIdx = 0
        int rows = self.mapSize.y
        int cols = self.mapSize.x
        int offsetx = -cols / 2 * tilew * 1
        int offsety = -rows / 2 * tilew * 1

        for int y = 0; y < self.mapSize.y - 1; y++{
            for int x = 0; x < self.mapSize.x - 1 ; x++{
                int idx = x + y * self.mapSize.x
                //int ridx = x+1 + y * self.mapSize.x
                //int rtidx = x+1 + (y+1) * self.mapSize.x
                //int tidx = x + y * self.mapSize.x
                W3eCorner* corner = (W3eCorner*)self.corners.get(idx)
                W3eCorner* corner_rb = (W3eCorner*)self.corners.get((x + 1) + (y + 0) * self.mapSize.x)
                W3eCorner* corner_rt = (W3eCorner*)self.corners.get((x + 1) + (y + 1) * self.mapSize.x)
                W3eCorner* corner_lt = (W3eCorner*)self.corners.get((x + 0) + (y + 1) * self.mapSize.x)
                //W3eCorner* right = self.corners.get(idx)

                float vx = x * tilew + offsetx
                float vy = y * tilew + offsety
                float rate = 1.0
                // int vertIdx = buf.floatSize() / 3
                //4个顶点
                buf.appendFloat3(vx, vy, corner.actualGroundHeight)
                buf.appendFloat3(vx + tilew * rate, vy, corner_rb.actualGroundHeight)
                buf.appendFloat3(vx + tilew * rate, vy + tilew * rate, corner_rt.actualGroundHeight)
                buf.appendFloat3(vx, vy + tilew * rate, corner_lt.actualGroundHeight)

                // printf("actualGroundHiehgt:%f\n", corner.actualGroundHeight)

                // uv0.appendFloat2(0.0, 0.75) // lb顶点
                // uv0.appendFloat2(0.125, 0.75) // rb顶点
                // uv0.appendFloat2(0.125, 1.0) // rt顶点
                // uv0.appendFloat2(0.0, 1.0) // lt顶点


                //构建 tilesets, uv0-3
                float curTilesets[4]
                FloatsProxy tilesetsProxy = mkFloatsProxy(curTilesets, 4)
                tilesetsProxy.appendFloat4(
                    corner.groundTexture,
                    corner_rb.groundTexture,
                    corner_rt.groundTexture,
                    corner_lt.groundTexture,
                )
                tilesetsProxy.distinctSelf()
                tilesetsProxy.fillRemainsByValue(17)//17表示无效的tileset

                Floats_bubbleSort(curTilesets, 4, true)

                tilesets.appendFloats( curTilesets, 4)//顶点0
                tilesets.appendFloats( curTilesets, 4)//顶点1
                tilesets.appendFloats( curTilesets, 4)//顶点2
                tilesets.appendFloats( curTilesets, 4)//顶点3

                // printf("tileset:%f,%f,%f,%f\n", 
                //     curTilesets[0],
                //     curTilesets[1],
                //     curTilesets[2],
                //     curTilesets[3],
                // )

                //构建uv
                for int i = 0; i < tilesetsProxy.size; i++{
                    float texture = curTilesets[i]
                    int bit = 0 //确定是哪个subtile
                    if texture == corner.groundTexture {
                        bit |= 0b0010;
                    }
                    if texture == corner_rb.groundTexture {
                        bit |= 0b0001;
                    }
                    if texture == corner_rt.groundTexture {
                        bit |= 0b0100;
                    }
                    if texture == corner_lt.groundTexture {
                        bit |= 0b1000;
                    }
                    int tilex = (bit % 4)
                    int tiley = (bit / 4)
                    float u = tilex * 0.125 
                    float u1 = u + 0.125

                    float v1 = 1.0 - tiley * 0.25
                    float v = v1 - 0.25

                    if bit == 0 || bit >= 15 {
                        // printf("groundVariation:%d\n", corner.groundVariation)
                        int extx = (corner.groundVariation % 16) % 4
                        int exty = (corner.groundVariation % 16) / 4

                        u = extx * 0.125 + 0.5
                        u1 = u + 0.125 

                        v1 = 1.0 - exty * 0.25
                        v = v1 - 0.25
                    }

                    u += 0.001
                    v += 0.001
                    u1 -= 0.001
                    v1 -= 0.001

                    Buffer* uv = uv0
                    if i == 1 { uv = uv1 }
                    else if i == 2 { uv = uv2 }
                    else if i == 3 { uv = uv3 }

                    //每个纹理下，每个纹理的uv
                    uv.appendFloat2(u, v) // lb顶点
                    uv.appendFloat2(u1, v) // rb顶点
                    uv.appendFloat2(u1, v1) // rt顶点
                    uv.appendFloat2(u, v1) // lt顶点
                }
                //其他层的纹理的uv也需要占位
                for int i = tilesetsProxy.size; i < 4; i++{
                    Buffer* uv = uv0
                    if i == 1 { uv = uv1 }
                    else if i == 2 { uv = uv2 }
                    else if i == 3 { uv = uv3 }

                    //每个纹理下，每个纹理的uv
                    uv.appendFloat2(0, 0) // lb顶点
                    uv.appendFloat2(0, 0) // rb顶点
                    uv.appendFloat2(0, 0) // rt顶点
                    uv.appendFloat2(0, 0) // lt顶点
                }

                //buf.appendFloat3(x + tilew, y, 0)
                //buf.appendFloat3(x + tilew, y + tileh, 0)
                //buf.appendFloat3(x, y + tileh, 0)
                
                if x < cols - 1 && y < rows - 1 {
                    int lb = vertIdx
                    int rb = vertIdx + 1
                    int rt = vertIdx + 2
                    int lt = vertIdx + 3
                    // int lb = x + y * cols
                    // int rb = x + 1 + y * cols
                    // int rt = x + 1 + (y + 1) * cols
                    // int lt = x + (y + 1) * cols
                
                    face.appendInt3(
                        lb, rb, rt
                    )
                    face.appendInt3(
                        lb, rt, lt
                    )
                }
                vertIdx += 4
            }
        }

        // buf.clear()
        // face.clear()

        // buf.appendFloat3(-0.5, -0.5, 0)
        // buf.appendFloat3(0.5, -0.5, 0)
        // buf.appendFloat3(0.5, 0.5, 0)
        // buf.appendFloat3(-0.5, 0.5, 0)
        // face.appendInt3(0, 1, 3)
        // face.appendInt3(1, 2, 3)

        Geometry@ r = new Geometry()
        r.setAttrByBuffer("position", buf, 3)
        r.setAttrByBuffer("tilesets", tilesets, 4)
        r.setAttrByBuffer("uv0", uv0, 2)
        r.setAttrByBuffer("uv1", uv1, 2)
        r.setAttrByBuffer("uv2", uv2, 2)
        r.setAttrByBuffer("uv3", uv3, 2)
        r.setIboByBuffer(face)

        return r
    }

    void mkGroundTexs(){
        for int i = 0; i < self.groundTilesetNames.size(); i++{
            String* name = (String*)self.groundTilesetNames.get(i)
            Tex2d@ tex = new Tex2d()
            String@ path = str("../asset/").add(name.str).add(".png")
            tex.loadImageByPathCstr(path.str)
            printf("mkGroundTexs. i:%d, path:%s\n", i, path.str)
            self.groundTexs.add(tex)
        }
    }
    void setUniformTexs(Material*matl){
        for int i = 0; i < self.groundTexs.size(); i++{
            Tex2d* tex = self.groundTexs.get(i)
            matl.setUniformTex2d(str("tex").addi(i).str, tex)
        }
    }

    void load(const char *path){
        Buffer@ buf = Buffer_readFile(path)
        BufferReader@ br = mkBufferReader(buf)

        self.head = br.readString(4)
        self.version = br.readInt()
        self.tileset = br.readByte()
        self.haveCustomTileset = br.readInt()

        self.groundTilesetCount = br.readInt();
        for int i = 0; i < self.groundTilesetCount; i++{
            String@ name = br.readString(4)
            self.groundTilesetNames.add(name)
            printf("groundTilesetNames:%s\n", name.str)
        }

        self.cliffTilesetCount = br.readInt();
        for int i = 0; i < self.cliffTilesetCount; i++{
            String@ name = br.readString(4)
            self.cliffTilesetNames.add(name)
        }

        br.readBinary(&self.mapSize, sizeof(IntVec2));
        br.readBinary(&self.centerOffset, sizeof(Vec2));

        for int row = 0; row < self.mapSize.y; row++{
            for int col = 0; col < self.mapSize.x; col++{
                W3eCorner@ corner = new W3eCorner()
                corner.load(br)
                self.corners.add(corner)
            }
        }
    }

}